# 第二章 信息的表示和处理

### 2.1 信息存储

---

大多数计算机使用8 位的块，或者**字节** （byte）, 作为最小的可寻址的内存单位。

机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存** （virtual memory） 。

内存的每个字节都由一个唯一的数字来标识，称为它的**地址** （address）。

所有可能地址的集合就称为**虚拟地址空间** （virtual address space），这个虚拟地址空间只是一个展现给机器级程序的概念性映像。

#### 2.1.1 十六进制表示法

十六进制表示、十六进制和十进制的互相转换。

#### 2.1.2 字数据大小

每台计算机都有一个**字长** （word size）， 指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为$w$位的机器而言，虚拟地址的范围为$0\sim 2^w-1$，程序最多访问$2^w$个字节。

32 位字长限制虚拟地址空间为4 千兆字节（写作4GB，1G=$2^{30}$）, 也就是说，刚刚超过$4\times 10^9$字节。扩展到64 位字长使得虚拟地址空间为16EB, 大约是$1.84\times 10^{19} $字节。

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210811191106.png)

**可移植性：** 许多程序员假设一个声明为`int` 类型的程序对象能被用来存储一个指针。这在大多数32 位的机器上能正常工作，但是在一台64 位的机器上却会导致问题。

#### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，必须建立两个规则：这个**对象的地址是什么** ，以及**在内存中如何排列这些字节** 。

在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，称为**小端法** （little endian）；而另一些机器则按照从最高有效字节到最低有效字节的顺序存储，称为**大端法** （big endian）。

以`int`类型的变量`x`为例，假设其位于地址`0x100`处，它的16进制值为`0x01234567`。地址范围`0x100~0x103`的字节顺序依赖于机器的类型：

<img src="https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210811194257.png" style="zoom:45%;" />

在有些时候，字节顺序会成为问题：

1. 是在不同类型的机器之间通过网络传送二进制数据时， 一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关千字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。

2. 当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在阅读由反汇编器生成的机器级代码时。

3. 当编写规避正常的类型系统的程序时。

**打印程序对象的字节表示：** 

```C
#include <stdio.h>

typedef unsigned char *byte_pointer;//用typedef将数据类型byte_pointer定义为一个指向类型为unsigned char的对象的指针

void show_bytes(byte_pointer start,size_t len){//输入参数是一个字节序列的地址，用一个字节指针和一个字节数来表示。
  size_t i;
  for(i = 0;i < len;i++){
    printf("%.2x",start[i]);//表示整数必须用至少两个数字的十六进制格式输出。
  }
  printf("\n");
}//打印出每个以十六进制表示的字节。

void show_int(int x){//&x被强制类型转换为"unsigned char *"，即把这个指针看成指向一个字节序列的对象
  show_bytes((byte_pointer) &x,sizeof(int));//使用sizeof增加可移植性
}

void show_float(float x){
  show_bytes((byte_pointer) &x,sizeof(float));
}

void show_pointer(void *x){
  show_bytes((byte_pointer) &x,sizeof(void *));
}

void test_show_bytes(int val){
  int ival = val;
  float fval = (float) ival;
  int *pval = &ival;
  show_int(ival);
  show_float(fval);
  show_pointer(pval);
} 

```


#### 2.1.4 表示字符串

C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。

在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210811205814.png)

#### 2.1.5 表示代码

对于下面的C函数

```C
int sum(int x,int y){
  return x+y;
}
```


在不同机器上生成的字节表示的机器代码是不同的：

```纯文本
Linux 32    55 89 e5 8b 45 0c 03 45 08 c9 c3
Windows     55 89 e5 8b 45 0c 03 45 08 5d c3
Sum         81 c3 e0 08 90 02 00 09
Linux 64    55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3

```


不同的机器类型使用不同的且不兼容的指令和编码方式，二进制代码是不兼容的。

计算机系统的一个基本概念是，从机器的角度来看，程序仅仅只是字节序列。

#### 2.1.6 布尔代数简介

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210811220014.png)

#### 2.1.7 C语言中的位运算

C语言使用的符号和布尔运算中使用的符号相同：`|`就是或，`&`就是与，`~`就是取反，`^`就是异或

位级运算的一个常见用法就是实现**掩码** 运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。例如：掩码`0xFF`（最低的8 位为1）表示一个字的低位字节。位级运算`x&0xFF`生成一个由`x`的最低有效字节组成的值，而其他的字节就被置为0 。比如，对于`x=0x89ABCDEF`其表达式将得到`0x000000EF`

#### 2.1.8 C语言中的逻辑运算

C语言中的逻辑运算符`||`、`&&`和`!`分别对应于命题逻辑中的OR、AND和NOT运算。

逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或0，分别表示结果为TRUE或者FALSE。例如：

<img src="https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210811221815.png" style="zoom:44%;" />

#### 2.1.9 C语言中的移位运算

对于一个位表示为$[x_{w-1},x_{w-2},\cdots,x_0]$的操作数$x$

**左移运算：** `x<<k`生成位表示为$[x_{w-k-1},x_{w-k-2},\cdots,x_0,0,\cdots,0]$的值。即$x $向左移动$k$位，丢弃最高的$k $位，并在右端补$k$个0。

**右移运算：** `x>>k`，分为**逻辑右移** 和**算术右移** 。逻辑右移在左端补$k $个0，得到结果是$[0,\cdots,0,x_{w-1},x_{w-2},\cdots,x_k]$；算术右移在左端补$k$个最高有效位的值，得到的结果是$[x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\cdots,x_k]$。

<img src="https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210812094058.png" style="zoom:50%;" />

C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移，但是，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。

Java对于如何进行右移有明确的定义，`x>>k`会将`x`进行算术右移，而`x>>>k`会对`x`进行逻辑右移。

对于一个由$w$位组成的数据类型，当移动$k\geq w$位时，实际位移量是通过计算$k\mod w$得到的。例如，假设数据类型`int`为$w=32$

```C
int      lval = 0xFEDCBA98  << 32; //0xFEDCBA98
int      aval = 0xFEDCBA98  << 36; //0xFFEDCBA9
unsigned uval = 0xFEDCBA98u >> 40; //0x00FEDCBA
```


### 2.2 整数表示

---

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210812104559.png)

#### 2.2.1 整数数据类型

|C数据类型|32位|64位|
|---|---|---|
|`[signed]char`|$-2^7\sim 2^7-1$|$-2^7\sim 2^7-1$|
|`unsigned char`|$0\sim2^8-1$|$0\sim2^8-1$|
|`short`|$-2^{15}\sim 2^{15}-1$|$-2^{15}\sim 2^{15}-1$|
|`unsigned short`|$0\sim 2^{16}-1$|$0\sim 2^{16}-1$|
|`int`|$-2^{31}\sim 2^{31}-1$|$-2^{31}\sim 2^{31}-1$|
|`unsigned long`|$0\sim 2^{32}-1$|$0\sim 2^{32}-1$|
|`long`|$-2^{31}\sim 2^{31}-1$|$-2^{63}\sim2^{63}-1$|
|`unsigned long`|$0\sim 2^{32}-1$|$0\sim 2^{64}-1$|
|`int32_t`|$-2^{31}\sim 2^{31}-1$|$-2^{31}\sim 2^{31}-1$|
|`uint_t`|$0\sim 2^{32}-1$|$0\sim 2^{32}-1$|
|`int64_t`|$-2^{63}\sim2^{63}-1$|$-2^{63}\sim2^{63}-1$|
|`uint64_t`|$0\sim 2^{64}-1$|$0\sim 2^{64}-1$|



C和C++都支持有符号数（默认）和无符号数，Java只支持有符号数。

#### 2.2.2 无符号数的编码

**无符号数编码的定义：** 对于向量$\boldsymbol{x}=[x_{w-1},x_{w-2},\cdots,x_0]$：

$$
B2U_w(\boldsymbol{x})\doteq \sum_{i=0}^{w-1} x_i2^i
$$


$w$位所能表示的值的范围为：最小是0，最大是$\displaystyle{UMax_w\doteq \sum_{i=0}^{w-1}2^i}=2^w-1$

#### 2.2.3 补码编码

**补码编码的定义：** 对于向量$\boldsymbol{x}=[x_{w-1},x_{w-2},\cdots,x_0]$：

$$
B2T_w(\boldsymbol{x})\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2} x_i2^i
$$


$w$位所能表示的值的范围为：最小是$TMin_w\doteq-2^{w-1}$，最大是$TMax_w\doteq 2^{w-1}-1$

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210813094844.png)

#### 2.2.4 有符号数和无符号数之间的转换

**补码转换为无符号数：** 对满足$TMin_w\leq x\leq TMax_w$的$x $有：

$$
T2U_w(x)=\left\{\begin{array}{ll}
x+2^w, & x<0\\
x, & x\geq 0
\end{array}\right.
$$


**无符号数转换为补码：** 对满足$0\leq u\leq UMax_w$的$u$有：

$$
U2T_w(u)=\left\{\begin{array}{ll}
u, & u\leq TMax_w\\
u-2^w, & u> TMax_w
\end{array}\right.
$$


$-A$**的表示可以通过把** $A$**的反码加1得到，即“** **取反加1** **”。** （无论是负数转换为无符号数，还是无符号转换为负数都适用）

#### 2.2.5 C语言中的有符号数与无符号数

显式强制类型转换：

```C
int tx,ty;
unsigned ux,uy;
tx = (int) ux;
uy = (unsigned) ty;
```


隐式类型转换：

```C
int tx,ty;
unsigned ux,uy;
tx = ux; //转换为有符号数
uy = ty; //转换为无符号数
```


**在32位机器上运行以下代码：** 

```C
int x = -1;//1111 1111 1111 1111 1111 1111 1111 1111,0xFFFF FFFF
unsigned u = 2147483648; //2^31,1000 0000 0000 0000 0000 0000 0000 0000,0x8000 0000
printf("x = %u = %d\n",x,x); //x = 429497295 = -1
printf("u = %u = %d\n",u,u); //u = 2147483648 = -2147483648
```


#### 2.2.6 拓展一个数字的位表示

**无符号数的零拓展：** 定义宽度为$w$的位向量$\boldsymbol{u}=[u_{w-1},u_{w-2},\cdots,u_0]$和宽度为$w'$的位向量$\boldsymbol{u'}=[0,\cdots,0,u_{w-1},u_{w-2},\cdots,u_0]$，其中$w'>w$。则$B2U_w(\boldsymbol{u})=B2U_{w'}(\boldsymbol{u'})$。

**补码数的符号拓展：** 定义宽度为$w$的位向量$\boldsymbol{x}=[x_{w-1},x_{w-2},\cdots,x_0]$和宽度为$w'$的位向量$\boldsymbol{x'}=[x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\cdots,x_0]$，其中$w'>w$。则$B2U_w(\boldsymbol{x})=B2U_{w'}(\boldsymbol{x'})$。

#### 2.2.7 截断数字

```C
int x = 53191; //0000 0000 0000 0000 1100 1111 1100 0111
short sx = (short) x; //-12345
int y = sx; //-12345    12345->0011 0000 0011 1001
```


**截断无符号数：** 令$\boldsymbol{x}$等于位向量$[x_{w-1},x_{w-2},\cdots,x_0]$，而$\boldsymbol{x'}$是将其截断为$k$位的结果：$\boldsymbol{x'}=[x_{k-1},x_{k-2},\cdots,x_0]$。令$x=B2U_w(\boldsymbol{x})$,$x'=B2U_k(\boldsymbol{x'})$。则$x'=x\mod 2^k$。

**截断补码数值：** 令$\boldsymbol{x}$等于位向量$[x_{w-1},x_{w-2},\cdots,x_0]$，而$\boldsymbol{x'}$是将其截断为$k$位的结果：$\boldsymbol{x'}=[x_{k-1},x_{k-2},\cdots,x_0]$。令$x=B2U_w(\boldsymbol{x})$,$x'=B2T_k(\boldsymbol{x'})$。则$x'=U2T_k(x\mod 2^k)$。

#### 2.2.8 关于有符号数与无符号数的建议

```C
**/* WARNING: This is buggy code. */** 
float sum_elements(float a[],unsigned length){
  int i;
  float result = 0;
  
  for(i = 0;i <= lenght-1;i++){
    result += a[i];
  }
  return result;
}
```


当参数`length`等于0时，运行上面的代码应该返回`0.0`，可实际上运行时会遇到一个内存错误。

因为参数`length`是无符号的，计算`0-1`将使用无符号运算，这等价于模数加法。结果得到$UMax$。$\leq $同样使用无符号数比较，而因为任何数都小于等于$UMax$，所以总是为真，因此代码将试图访问数组`a`的非法元素。

### 2.3 整数运算

---

#### 2.3.1 无符号加法

**无符号数加法（** $+_w^u$**）：** 对满足$x\geq 0,y<2^w$的$x$和$y$有：

$$
x+_w^u y=\left\{\begin{array}{lll}
 x+y, & x+y<2^w & \text{正常}\\
 x+y-2^w, & 2^w\leq x+y<2^{w+1} & \text{溢出}
\end{array}\right. 
$$


**检测无符号数加法中的溢出：** 对在范围$x\geq 0,y\leq UMax_w$中的$x$和$y $，令$s\doteq x+_w^uy$。则对计算$s$，当且仅当$s<x$（或等价地$s<y$）时，发生了溢出。

无符号数求反：对满足$0\leq x<2^w$的任意$x$，其$w$位的无符号逆元$-_w^ux$由下式给出：

$$
-^u_wx=\left\{\begin{array}{ll}
 x, & x=0 \\
 2^w-x, & x>0 
\end{array}\right. 
$$


#### 2.3.2 补码加法

**补码加法：** 对满足$x\geq -2^{w-1},y\leq2^{w-1}-1$的整数$x$和$y$，有：

$$
x+_w^t y=\left\{\begin{array}{lll}
 x+y-2^w, & x+y\geq 2^{w-1} & \text{正溢出}\\
 x+y, & -2^{w-1}\leq x+y<2^{w-1} & \text{正常}\\
 x+y+2^w, & x+y<-2^{w-1} & \text{负溢出}
\end{array}\right. 
$$

<img src="https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210813151047.png" style="zoom: 33%;" />

**检测补码加法中的溢出：** 对满足$x\geq TMin_w,y\leq TMax_w$的$x$和$y$，令$s\doteq x+_w^t y$。当且仅当$x>0,y>0$，但$s\leq 0$时，计算$s$发生了正溢出。当且仅当$x<0,y<0$，但$s\geq 0$时，计算$s$发生了负溢出。

#### 2.3.3 补码的非

**补码的非：** 对满足$TMin_w\leq x\leq TMax_w$的$x$，其补码的非$-_w^tx$由下式给出

$$
-^t_wx=\left\{\begin{array}{ll}
 TMin_w, & x=TMin_w\\
 -x, & x>TMin_w 
\end{array}\right. 
$$


**补码非的位级表示：** （1）对每一位求补，再对结果加1（取反加1）

<img src="https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210813161909.png" style="zoom:44%;" />

（2）设$k$是$x$最右边的1的位置（从右往左数的第一个1），因而$x$的位级表示形如$[x_{w-1},x_{w-2},\cdots,x_{k+1},1,0,\cdots,0]$，这个值的非写成二进制格式就是$[\sim x_{w-1},\sim x_{w-2},\cdots,\sim x_{k+1},1,0,\cdots,0]$。也就是对位$k$左边的所有位取反。

#### 2.3.4 无符号乘法

**无符号数乘法：** 对满足$x\geq 0,y\leq UMax_w$的$x$和$y$有：

$$
x*_w^u y=(x\cdot y)\mod 2^w
$$


#### 2.3.5 补码乘法

**补码乘法：** 对满足$x\geq TMin_w,y\leq TMax_w$的$x$和$y$有：

$$
x*_w^ty=U2T_w((x\cdot y)\mod 2^w)
$$


**无符号和补码乘法的位级等价性：** 给定长度为$w$的位向量$\boldsymbol{x}$和$\boldsymbol{y}$，用补码形式的位向量表示来定义整数$x$和$y$：$x=B2T_w(\boldsymbol{x}),y=B2T_w(\boldsymbol{y})$。用无符号形式的位向量表示来定义非负整数$x'$和$y'$：$x'=B2U_w(\boldsymbol{x}),y'=B2U_w(\boldsymbol{y})$。则

$$
T2B_w(x*_w^ty)=U2B_w(x'*_w^uy') 
$$


#### 2.3.6 乘以常数

**乘以2的幂：** 设$x$为位模式$[x_{w-1},x_{w-2},\cdots,x_0]$表示的无符号整数。那么，对于任何$k\geq0$，都认为$[x_{w-1},x_{w-2},\cdots,x_0,0,\cdots,0]$给出了$x2^k$的$w+k$位的无符号表示，这里右边增加了$k$个$0$

**与2的幂相乘的无符号乘法：** C变量`x`和`k`有无符号数值$x$和$k$，且$0\leq k<w$，则C表达式`x<<k`产生数值$x*_w^u2^k$。

**与2的幂相乘的补码乘法：** C变量`x`和`k`有补码值$x$和无符号数值$k$，且$0\leq k<w$，则C表达式`x<<k`产生数值$x*_w^t2^k$。

由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。例如对于表达式`x*14`，编译器会将其重写为`(x<<3)+(x<<2)+(x<<1)`或`(x<<4)-(x<<1)`。

#### 2.3.7 除以2的幂

**除以2的幂的无符号除法：** C变量`x`和`k`有无符号数值$x$和$k$，且$0\leq k<w$，则C表达式`x>>k`产生数值$\lfloor x/2^k\rfloor$。

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210813210319.png)

**除以2的幂的补码除法，向下舍入：** C变量`x`和`k`有补码值$x$和无符号数值$k$，且$0\leq k<w$，则当执行算术移位时，C表达式`x>>k`产生数值$\lfloor x/2^k\rfloor$。

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210813210907.png)

**除以2的幂的补码除法，向上舍入：** C变量`x`和`k`有补码值$x$和无符号数值$k$，且$0\leq k<w$，则当执行算术移位时，C表达式`(x+(1<<k)-1)>>k`产生数值$\lceil x/2^k\rceil$。

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210813211258.png)

对于使用算术右移的补码机器，C表达式`(x<0 ? x+(1<<k)-1 : x) >> k`将会计算数值$x/2^k$。

> 写一个函数`div16`，对于整数参数`x`返回`x/16`的值。函数中不能使用除法、模运算、乘法、任何条件语句、任何比较运算符或任何循环。假设数据类型`int`是32位长，使用补码表示，右移是算术右移。


```C
/* 利用表达式x>>31产生一个字，如果x是负数，这个字为全1，否则为全0。
   通过掩码屏蔽掉适当的位就可以得到期望的偏置值 */
int div16(int x){
  /* Compute bias to be either 0(x >=0) or 15(x < 0) */
  int bias = (x>>31) & 0xF;
  return (x+bias) >>4;
}
```


### 2.4 浮点数

---

浮点数对形如$V=x\times 2^y$的有理数进行编码。

#### 2.4.1 二进制小数

考虑一个形如

$$
b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n-1}b_{-n}
$$


的表示法，其中每个二进制数字，或者称为位，$b_i$的取值范围是0和1，如下图所示。这种表示方法表示的数$b$定义如下：

$$
b=\sum_{i=-n}^m2^i\times b_i
$$

<img src="https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210814092115.png" style="zoom:40%;" />

#### 2.4.2 IEEE浮点表示

IEEE浮点数标准用$V={(-1)}^s\times M\times 2^E$的形式来表示一个数：

- **符号：** $s$决定这数是负数（$s=1$）还是正数（$s=0$），而对于数值0的符号位解释作为特殊情况处理

- **尾数：** $M$是一个二进制小数，它的范围是$1\sim2-\varepsilon$，或者是$0\sim 1-\varepsilon$

- **阶码：** $E$的作用是对浮点数加权，这个权重是2的$E$次幂（可能是负数）

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

- 一个单独的符号位$s$直接编码符号$s$

- $k$位的阶码字段`exp`=$e_{k-1}\cdots e_1e_0$编码阶码$E$

- $n$位小数字段`frac`=$f_{n-1}\cdots f_1f_0$编码尾数$M$，但是编码出来的值也依赖于阶码字段的值是否等于0

在单精度浮点格式中，`s`、`exp`和`frac`字段分别为$1$**位、** $k=8$**位和** $n=23$**位** ，得到一个32位的表示。在双精度浮点格式中，`s`、`exp`和`frac`字段分别为$1$**位、** $k=11$**位和** $n=52$**位** ，得到一个64位的表示。

<img src="https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210814095306.png" style="zoom:40%;" />

给定位表示，根据`exp`的值，被编码的值可以分成三种不同的情况：

<img src="https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210814100211.png" style="zoom:33%;" />

**情况1：规格化的值** 

当`exp`的位模式既不全为0，又不全为1时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置形式表示的有符号整数。也就是说，阶码的值是$E=e-Bias$，其中$e$是无符号数，其位表示为$e_{k-1}\cdots e_1e_0$，而$Bias$是一个等于$2^{k-1}-1$**（单精度是127，双精度是1023）** 的偏置量。由此产生指数的取值范围，**对于单精度是** $-126\sim+127$**，而对于双精度是** $-1022\sim +1023$。

小数字段`frac`被解释为描述小数值$f$，其中$0\leq f<1$，其二进制表示为$0.f_{n-1}\cdots f_1f_0$，也就是二进制小数点在最高有效位的左边。尾数定义为$M=1+f$。这种方式也叫**隐含的以1开头** 的表示，因为可以把$M$看成一个二进制表达式为$1.f_{n-1}\cdots f_1f_0$的数字。实际上是用23位来表示一个24位的数字。

**情况2：非规格化的值** 

当阶码域全为0时，所表示的数是非规格化的形式。在这种情况下， 阶码值是$E=1-Bias$（**单精度是** $-126$**，双精度是** $-1022 $），而尾数的值是$M=f$，也就是小数字段的值，没有隐含的开头的1。

**情况3：特殊值** 

这一类数值是当阶码域全为1时出现的。当小数域全为0时，得到的值表示无穷，当$s=0$时是正无穷，当$s=1 $时是负无穷。当小数域为非0时，表示$NaN$。

#### 2.4.3 数字示例

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210814143353.png)

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210814142933.png)

#### 2.4.4 舍入

![](https://typora-vohsiliu.oss-cn-hangzhou.aliyuncs.com/20210814154658.png)

向偶数舍入也被称为向最接近的值舍入，是默认的方式，试图找到一个最接近的匹配值。它将数字向上或者向下舍入，使得结果的最低有效数字是偶数。

其他三种方式产生实际值的确界。向零舍入方式把正数向下舍入，把负数向上舍入，得到值$\hat{x}$，使得$|\hat{x}|\leq |x|$。向下舍入方式把正数和负数都向下舍入，得到值$x^-$，使得$x^-\leq x$。向上舍入方式把正数和负数都向上舍入，得到值$x^+$，满足$x^+\geq x$。

对于向偶数舍入来讲，它最大的作用是在统计时使用。**向偶数舍入可以让我们在统计时，将舍入产生的误差平均，从而尽可能的抵消** 。而其它三种方式在这方面都是有一定缺陷的，向上和向下舍入会造成值的偏大或偏小。而对于向零舍入来讲，如果全是正数的时候则会造成结果偏小，全是负数的时候则会造成结果偏大。

**向偶数舍入规则** ：例如有效数字超出规定数位的多余数字是1001，它大于超出规定最低位的一半（即0.5），故最低位进1。如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数）即可。对于多余数字是1000（正好是最低位一半）的特殊情况，若最低位为0则舍掉多余位，最低为1则进位1，使得最低位仍为0（偶数）。 

|舍入前|舍入后（舍入到最接近的二分之一）|
|---|---|
|$10.010_2$|$10.0_2$|
|$10.011_2$|$10.1_2$|
|$10.110_2<br />$|$11.0_2$|
|$11.001_2$|$11.0_2$|



#### 2.4.5 浮点运算

- **浮点加法不具有结合性。** 例如，`(3.14+1e10)-1e10`结果为0.0，而`3.14+(1e10-1e10)`结果为3.14。

- **浮点加法满足单调性：** 如果$a\geq b $，那么对于任何$a,b$及$x$的值，除了$NaN $，都有$x+a\geq x+b$。无符号或补码加法不具有这个性质。

- **浮点乘法是可交换的，不具有结合性，在加法上不具有分配性，满足单调性，且只要** $a\neq NaN$**，就有** $a*a\geq 0$**。** 

#### 2.4.6 C语言中的浮点数

- 所有的C语言版本提供了两种不同的浮点数据类型：`float`和`double`。在支持IEEE浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。

- 这类机器使用向偶数舍入的舍入方式。

- 因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式或者得到诸如$-0$、$+\infty$、$-\infty$或者$NaN$之类的特殊值。

- 可以通过引入库函数`math.h`定义程序常数`INFINITY`和`NAN`。

- 从`float`或`double`转换成`int`时，值会向零舍入。进一步来说，值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式$[100\cdots000]$（字长为$w$时的$TMin_w$）为整数不确定值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此`(int) 1e10`会得到`-2147483648`，即从一个正值变为一个负值。

### 2.5 小结

---

计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。

C语言的设计可以包容多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代统治市场长达30多年的32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。

大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。在位级上理解这些编码，并且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。

在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个$w$位的值，这种行为是由函数$T2U_w$和$U2T_w$来描述的。C语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。

由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于$0.0$, 从而转换成零时，也会下溢。

和大多数其他程序语言一样， C语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式`x*x` 能够得出负数。但是，无符号数和补码的运算都满足整数运算的许多其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，用`(x<<3)-x`取代表达式`7*x`时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以2 的幂之间的关系。

我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算， `~x+1`等价于`-x`。另外一个例子，假设我们想要一个形如$[0,\cdots,0,1,\cdots,1]$的位模式，由$w-k$个$0$后面紧跟着$k$个$1$组成。这些位模式有助于掩码运算。这种模式能够通过C表达式`(1<<k)-1`生成，利用的是这样一个属性，即我们想要的位模式的数值为$2^k-1$。例如，表达式`(1<<8)-1`将产生位模式`0xFF`。

浮点表示通过将数字编码为$x\times 2^y$的形式来近似地表示实数。最常见的浮点表示方式是由IEEE标准754定义的。它提供了几种不同的精度，最常见的是单精度（32位）和双精度（64位）。IEEE浮点也能够表示特殊值$+\infty$、$-\infty$和$NaN$ 。

必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属性，比如结合性。

